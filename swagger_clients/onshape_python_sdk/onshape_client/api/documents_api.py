# coding: utf-8

"""
    Onshape API

    Onshape API  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: ekeller@onshape.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from onshape_client.api_client import ApiClient


class DocumentsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def copy_workspace(self, did, wid, **kwargs):  # noqa: E501
        """Copy Workspace  # noqa: E501

        Copy a workspace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.copy_workspace(did, wid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param str wid: Workspace ID (required)
        :param DocumentsCopyWorkspaceBody body: The JSON request body.
        :return: DocumentsCopyWorkspaceResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.copy_workspace_with_http_info(did, wid, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_workspace_with_http_info(did, wid, **kwargs)  # noqa: E501
            return data

    def copy_workspace_with_http_info(self, did, wid, **kwargs):  # noqa: E501
        """Copy Workspace  # noqa: E501

        Copy a workspace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.copy_workspace_with_http_info(did, wid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param str wid: Workspace ID (required)
        :param DocumentsCopyWorkspaceBody body: The JSON request body.
        :return: DocumentsCopyWorkspaceResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did', 'wid', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_workspace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `copy_workspace`")  # noqa: E501
        # verify the required parameter 'wid' is set
        if ('wid' not in params or
                params['wid'] is None):
            raise ValueError("Missing the required parameter `wid` when calling `copy_workspace`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501
        if 'wid' in params:
            path_params['wid'] = params['wid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/{did}/workspaces/{wid}/copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsCopyWorkspaceResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_document(self, **kwargs):  # noqa: E501
        """Create Document  # noqa: E501

        Create document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_document(async=True)
        >>> result = thread.get()

        :param async bool
        :param DocumentsCreateDocumentBody body: The JSON request body.
        :return: DocumentsCreateDocumentResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_document_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_document_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_document_with_http_info(self, **kwargs):  # noqa: E501
        """Create Document  # noqa: E501

        Create document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_document_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param DocumentsCreateDocumentBody body: The JSON request body.
        :return: DocumentsCreateDocumentResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_document" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsCreateDocumentResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_version(self, did, **kwargs):  # noqa: E501
        """Create Version  # noqa: E501

        Create version at the current microversion of the specified workspace or a target microversion.                 Versions should be created only for tracking the state of a document that will need to be                 referenced by the user in the future. An application should not use versions as a convenience                 mechanism for an application to remember document states.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_version(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param DocumentsCreateVersionBody body: The JSON request body.
        :return: DocumentsCreateVersionResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_version_with_http_info(did, **kwargs)  # noqa: E501
        else:
            (data) = self.create_version_with_http_info(did, **kwargs)  # noqa: E501
            return data

    def create_version_with_http_info(self, did, **kwargs):  # noqa: E501
        """Create Version  # noqa: E501

        Create version at the current microversion of the specified workspace or a target microversion.                 Versions should be created only for tracking the state of a document that will need to be                 referenced by the user in the future. An application should not use versions as a convenience                 mechanism for an application to remember document states.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_version_with_http_info(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param DocumentsCreateVersionBody body: The JSON request body.
        :return: DocumentsCreateVersionResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `create_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/d/{did}/versions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsCreateVersionResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_workspace(self, did, **kwargs):  # noqa: E501
        """Create Workspace  # noqa: E501

        Creates a new workspace. The starting point for the workspace can be specified using one of                 microversionId, workspaceId, versionId in that precedence order. A workspace also has a parent                 that may be specified or implied. If the starting point is taken from workspaceId or versionId,                 the parent version is implied to be the workspace parent or the version, respectively. If the                 starting point used is microversionId then the parent version is chosen based on workspaceId,                 versionId and default workspace, in that precedence order. If chosen based on a workspaceId, the                 version is the parent of the chosen workspace. If the effective version parentId is not a true                 parent of the starting microversion, an error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_workspace(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param DocumentsCreateWorkspaceBody body: The JSON request body.
        :return: DocumentsCreateWorkspaceResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_workspace_with_http_info(did, **kwargs)  # noqa: E501
        else:
            (data) = self.create_workspace_with_http_info(did, **kwargs)  # noqa: E501
            return data

    def create_workspace_with_http_info(self, did, **kwargs):  # noqa: E501
        """Create Workspace  # noqa: E501

        Creates a new workspace. The starting point for the workspace can be specified using one of                 microversionId, workspaceId, versionId in that precedence order. A workspace also has a parent                 that may be specified or implied. If the starting point is taken from workspaceId or versionId,                 the parent version is implied to be the workspace parent or the version, respectively. If the                 starting point used is microversionId then the parent version is chosen based on workspaceId,                 versionId and default workspace, in that precedence order. If chosen based on a workspaceId, the                 version is the parent of the chosen workspace. If the effective version parentId is not a true                 parent of the starting microversion, an error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_workspace_with_http_info(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param DocumentsCreateWorkspaceBody body: The JSON request body.
        :return: DocumentsCreateWorkspaceResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_workspace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `create_workspace`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/d/{did}/workspaces', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsCreateWorkspaceResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_document(self, did, **kwargs):  # noqa: E501
        """Delete Document  # noqa: E501

        Delete a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_document(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_document_with_http_info(did, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_document_with_http_info(did, **kwargs)  # noqa: E501
            return data

    def delete_document_with_http_info(self, did, **kwargs):  # noqa: E501
        """Delete Document  # noqa: E501

        Delete a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_document_with_http_info(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `delete_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/{did}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_workspace(self, did, wid, **kwargs):  # noqa: E501
        """Delete Workspace  # noqa: E501

        Delete workspace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_workspace(did, wid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param str wid: Workspace ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_workspace_with_http_info(did, wid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_workspace_with_http_info(did, wid, **kwargs)  # noqa: E501
            return data

    def delete_workspace_with_http_info(self, did, wid, **kwargs):  # noqa: E501
        """Delete Workspace  # noqa: E501

        Delete workspace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_workspace_with_http_info(did, wid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param str wid: Workspace ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did', 'wid']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workspace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `delete_workspace`")  # noqa: E501
        # verify the required parameter 'wid' is set
        if ('wid' not in params or
                params['wid'] is None):
            raise ValueError("Missing the required parameter `wid` when calling `delete_workspace`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501
        if 'wid' in params:
            path_params['wid'] = params['wid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/d/{did}/workspaces/{wid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_external_data(self, fid, did, **kwargs):  # noqa: E501
        """Download External Data  # noqa: E501

        Download external data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.download_external_data(fid, did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str fid: External data ID (required)
        :param str did: Document ID (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.download_external_data_with_http_info(fid, did, **kwargs)  # noqa: E501
        else:
            (data) = self.download_external_data_with_http_info(fid, did, **kwargs)  # noqa: E501
            return data

    def download_external_data_with_http_info(self, fid, did, **kwargs):  # noqa: E501
        """Download External Data  # noqa: E501

        Download external data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.download_external_data_with_http_info(fid, did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str fid: External data ID (required)
        :param str did: Document ID (required)
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fid', 'did']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_external_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'fid' is set
        if ('fid' not in params or
                params['fid'] is None):
            raise ValueError("Missing the required parameter `fid` when calling `download_external_data`")  # noqa: E501
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `download_external_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'fid' in params:
            path_params['fid'] = params['fid']  # noqa: E501
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/d/{did}/externaldata/{fid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_element(self, wv_char, format, scale, mode, did, wv, eid, **kwargs):  # noqa: E501
        """Export Element (307)  # noqa: E501

        Export the given element in STL or Parasolid (PS) formats; returns a 307 redirect.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.export_element(wv_char, format, scale, mode, did, wv, eid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str wv_char: One of w or v corresponding to whether a workspace or version was entered. (required)
        :param str format: Export format: STL, PS (required)
        :param float scale: Scale for measurements (STL) (required)
        :param str mode: Type of file: text, binary (STL) (required)
        :param str did: Document ID (required)
        :param str wv: Workspace (w) or Version (v) ID (required)
        :param str eid: Element ID (required)
        :param bool store_in_document: whether the output should be stored as a new element
        :param str link_document_workspace_id: The id of the workspace in which the result should be           stored if storeInDocument is true and linkDocumentId is set.
        :param str part_ids: Comma-separated list of part IDs to export
        :param str microversion: Specified microversion for operation
        :param bool grouping: Whether parts should be exported as a group or individually in a           .zip file (STL)
        :param bool zip_single_file_output: Whether single file output should be returned as a           .zip file (STL, grouping==true)
        :param str units: Name of base unit: meter, centimeter, millimeter, inch, foot, yard (STL)
        :param float angle_tolerance: Angle tolerance (must be < pi/2) (STL)
        :param float chord_tolerance: Chord tolerance (STL)
        :param float max_facet_width: Maximum facet width (STL)
        :param float min_facet_width: Minimum facet width (must be < maximumFacetWidth) (STL)
        :param float version: Parasolid version (PS)
        :param str link_document_id: Id of document that links to the document being accessed.     This may provide additional access rights to the document. Allowed only with version (v) path parameter.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.export_element_with_http_info(wv_char, format, scale, mode, did, wv, eid, **kwargs)  # noqa: E501
        else:
            (data) = self.export_element_with_http_info(wv_char, format, scale, mode, did, wv, eid, **kwargs)  # noqa: E501
            return data

    def export_element_with_http_info(self, wv_char, format, scale, mode, did, wv, eid, **kwargs):  # noqa: E501
        """Export Element (307)  # noqa: E501

        Export the given element in STL or Parasolid (PS) formats; returns a 307 redirect.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.export_element_with_http_info(wv_char, format, scale, mode, did, wv, eid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str wv_char: One of w or v corresponding to whether a workspace or version was entered. (required)
        :param str format: Export format: STL, PS (required)
        :param float scale: Scale for measurements (STL) (required)
        :param str mode: Type of file: text, binary (STL) (required)
        :param str did: Document ID (required)
        :param str wv: Workspace (w) or Version (v) ID (required)
        :param str eid: Element ID (required)
        :param bool store_in_document: whether the output should be stored as a new element
        :param str link_document_workspace_id: The id of the workspace in which the result should be           stored if storeInDocument is true and linkDocumentId is set.
        :param str part_ids: Comma-separated list of part IDs to export
        :param str microversion: Specified microversion for operation
        :param bool grouping: Whether parts should be exported as a group or individually in a           .zip file (STL)
        :param bool zip_single_file_output: Whether single file output should be returned as a           .zip file (STL, grouping==true)
        :param str units: Name of base unit: meter, centimeter, millimeter, inch, foot, yard (STL)
        :param float angle_tolerance: Angle tolerance (must be < pi/2) (STL)
        :param float chord_tolerance: Chord tolerance (STL)
        :param float max_facet_width: Maximum facet width (STL)
        :param float min_facet_width: Minimum facet width (must be < maximumFacetWidth) (STL)
        :param float version: Parasolid version (PS)
        :param str link_document_id: Id of document that links to the document being accessed.     This may provide additional access rights to the document. Allowed only with version (v) path parameter.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wv_char', 'format', 'scale', 'mode', 'did', 'wv', 'eid', 'store_in_document', 'link_document_workspace_id', 'part_ids', 'microversion', 'grouping', 'zip_single_file_output', 'units', 'angle_tolerance', 'chord_tolerance', 'max_facet_width', 'min_facet_width', 'version', 'link_document_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_element" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'wv_char' is set
        if ('wv_char' not in params or
                params['wv_char'] is None):
            raise ValueError("Missing the required parameter `wv_char` when calling `export_element`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `export_element`")  # noqa: E501
        # verify the required parameter 'scale' is set
        if ('scale' not in params or
                params['scale'] is None):
            raise ValueError("Missing the required parameter `scale` when calling `export_element`")  # noqa: E501
        # verify the required parameter 'mode' is set
        if ('mode' not in params or
                params['mode'] is None):
            raise ValueError("Missing the required parameter `mode` when calling `export_element`")  # noqa: E501
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `export_element`")  # noqa: E501
        # verify the required parameter 'wv' is set
        if ('wv' not in params or
                params['wv'] is None):
            raise ValueError("Missing the required parameter `wv` when calling `export_element`")  # noqa: E501
        # verify the required parameter 'eid' is set
        if ('eid' not in params or
                params['eid'] is None):
            raise ValueError("Missing the required parameter `eid` when calling `export_element`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'wv_char' in params:
            path_params['wv_char'] = params['wv_char']  # noqa: E501
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501
        if 'wv' in params:
            path_params['wv'] = params['wv']  # noqa: E501
        if 'eid' in params:
            path_params['eid'] = params['eid']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'store_in_document' in params:
            query_params.append(('storeInDocument', params['store_in_document']))  # noqa: E501
        if 'link_document_workspace_id' in params:
            query_params.append(('linkDocumentWorkspaceId', params['link_document_workspace_id']))  # noqa: E501
        if 'part_ids' in params:
            query_params.append(('partIds', params['part_ids']))  # noqa: E501
        if 'microversion' in params:
            query_params.append(('microversion', params['microversion']))  # noqa: E501
        if 'grouping' in params:
            query_params.append(('grouping', params['grouping']))  # noqa: E501
        if 'zip_single_file_output' in params:
            query_params.append(('zipSingleFileOutput', params['zip_single_file_output']))  # noqa: E501
        if 'scale' in params:
            query_params.append(('scale', params['scale']))  # noqa: E501
        if 'units' in params:
            query_params.append(('units', params['units']))  # noqa: E501
        if 'angle_tolerance' in params:
            query_params.append(('angleTolerance', params['angle_tolerance']))  # noqa: E501
        if 'chord_tolerance' in params:
            query_params.append(('chordTolerance', params['chord_tolerance']))  # noqa: E501
        if 'max_facet_width' in params:
            query_params.append(('maxFacetWidth', params['max_facet_width']))  # noqa: E501
        if 'min_facet_width' in params:
            query_params.append(('minFacetWidth', params['min_facet_width']))  # noqa: E501
        if 'mode' in params:
            query_params.append(('mode', params['mode']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'link_document_id' in params:
            query_params.append(('linkDocumentId', params['link_document_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/d/{did}/{wv_char}/{wv}/e/{eid}/export', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_element_post_json(self, wv_char, did, wv, eid, **kwargs):  # noqa: E501
        """Export Element (URI)  # noqa: E501

        Export the given element in STL or Parasolid (PS) formats; returns an URI in the response body,                 client should GET this URI to initiate the export.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.export_element_post_json(wv_char, did, wv, eid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str wv_char: One of w or v corresponding to whether a workspace or version was entered. (required)
        :param str did: Document ID (required)
        :param str wv: Workspace (w) or Version (v) ID (required)
        :param str eid: Element ID (required)
        :param DocumentsExportElementPostJsonBody body: The JSON request body.
        :param str link_document_id: Id of document that links to the document being accessed.     This may provide additional access rights to the document. Allowed only with version (v) path parameter.
        :return: DocumentsExportElementPostJsonResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.export_element_post_json_with_http_info(wv_char, did, wv, eid, **kwargs)  # noqa: E501
        else:
            (data) = self.export_element_post_json_with_http_info(wv_char, did, wv, eid, **kwargs)  # noqa: E501
            return data

    def export_element_post_json_with_http_info(self, wv_char, did, wv, eid, **kwargs):  # noqa: E501
        """Export Element (URI)  # noqa: E501

        Export the given element in STL or Parasolid (PS) formats; returns an URI in the response body,                 client should GET this URI to initiate the export.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.export_element_post_json_with_http_info(wv_char, did, wv, eid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str wv_char: One of w or v corresponding to whether a workspace or version was entered. (required)
        :param str did: Document ID (required)
        :param str wv: Workspace (w) or Version (v) ID (required)
        :param str eid: Element ID (required)
        :param DocumentsExportElementPostJsonBody body: The JSON request body.
        :param str link_document_id: Id of document that links to the document being accessed.     This may provide additional access rights to the document. Allowed only with version (v) path parameter.
        :return: DocumentsExportElementPostJsonResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wv_char', 'did', 'wv', 'eid', 'body', 'link_document_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_element_post_json" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'wv_char' is set
        if ('wv_char' not in params or
                params['wv_char'] is None):
            raise ValueError("Missing the required parameter `wv_char` when calling `export_element_post_json`")  # noqa: E501
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `export_element_post_json`")  # noqa: E501
        # verify the required parameter 'wv' is set
        if ('wv' not in params or
                params['wv'] is None):
            raise ValueError("Missing the required parameter `wv` when calling `export_element_post_json`")  # noqa: E501
        # verify the required parameter 'eid' is set
        if ('eid' not in params or
                params['eid'] is None):
            raise ValueError("Missing the required parameter `eid` when calling `export_element_post_json`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'wv_char' in params:
            path_params['wv_char'] = params['wv_char']  # noqa: E501
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501
        if 'wv' in params:
            path_params['wv'] = params['wv']  # noqa: E501
        if 'eid' in params:
            path_params['eid'] = params['eid']  # noqa: E501

        query_params = []
        if 'link_document_id' in params:
            query_params.append(('linkDocumentId', params['link_document_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/d/{did}/{wv_char}/{wv}/e/{eid}/export', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsExportElementPostJsonResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_acl(self, did, **kwargs):  # noqa: E501
        """Get Access Control List  # noqa: E501

        Get list of entities with access to a document and the permissions granted to them. The caller     must have read access for the document.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_acl(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :return: DocumentsGetAclResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_acl_with_http_info(did, **kwargs)  # noqa: E501
        else:
            (data) = self.get_acl_with_http_info(did, **kwargs)  # noqa: E501
            return data

    def get_acl_with_http_info(self, did, **kwargs):  # noqa: E501
        """Get Access Control List  # noqa: E501

        Get list of entities with access to a document and the permissions granted to them. The caller     must have read access for the document.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_acl_with_http_info(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :return: DocumentsGetAclResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_acl" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `get_acl`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/{did}/acl', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsGetAclResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_current_microversion(self, wv_char, did, wv, **kwargs):  # noqa: E501
        """Get Current Document Microversion  # noqa: E501

        Get current microversion from a version or workspace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_current_microversion(wv_char, did, wv, async=True)
        >>> result = thread.get()

        :param async bool
        :param str wv_char: One of w or v corresponding to whether a workspace or version was entered. (required)
        :param str did: Document ID (required)
        :param str wv: Workspace (w) or Version (v) ID (required)
        :return: DocumentsGetCurrentMicroversionResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_current_microversion_with_http_info(wv_char, did, wv, **kwargs)  # noqa: E501
        else:
            (data) = self.get_current_microversion_with_http_info(wv_char, did, wv, **kwargs)  # noqa: E501
            return data

    def get_current_microversion_with_http_info(self, wv_char, did, wv, **kwargs):  # noqa: E501
        """Get Current Document Microversion  # noqa: E501

        Get current microversion from a version or workspace  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_current_microversion_with_http_info(wv_char, did, wv, async=True)
        >>> result = thread.get()

        :param async bool
        :param str wv_char: One of w or v corresponding to whether a workspace or version was entered. (required)
        :param str did: Document ID (required)
        :param str wv: Workspace (w) or Version (v) ID (required)
        :return: DocumentsGetCurrentMicroversionResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wv_char', 'did', 'wv']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_current_microversion" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'wv_char' is set
        if ('wv_char' not in params or
                params['wv_char'] is None):
            raise ValueError("Missing the required parameter `wv_char` when calling `get_current_microversion`")  # noqa: E501
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `get_current_microversion`")  # noqa: E501
        # verify the required parameter 'wv' is set
        if ('wv' not in params or
                params['wv'] is None):
            raise ValueError("Missing the required parameter `wv` when calling `get_current_microversion`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'wv_char' in params:
            path_params['wv_char'] = params['wv_char']  # noqa: E501
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501
        if 'wv' in params:
            path_params['wv'] = params['wv']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/d/{did}/{wv_char}/{wv}/currentmicroversion', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsGetCurrentMicroversionResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_document(self, did, **kwargs):  # noqa: E501
        """Get Document  # noqa: E501

        Get full details about a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_document(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :return: DocumentsGetDocumentResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_document_with_http_info(did, **kwargs)  # noqa: E501
        else:
            (data) = self.get_document_with_http_info(did, **kwargs)  # noqa: E501
            return data

    def get_document_with_http_info(self, did, **kwargs):  # noqa: E501
        """Get Document  # noqa: E501

        Get full details about a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_document_with_http_info(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :return: DocumentsGetDocumentResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `get_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/{did}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsGetDocumentResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_document_permission_set(self, did, **kwargs):  # noqa: E501
        """Get Document Permissions  # noqa: E501

        Get the permission set for a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_document_permission_set(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_document_permission_set_with_http_info(did, **kwargs)  # noqa: E501
        else:
            (data) = self.get_document_permission_set_with_http_info(did, **kwargs)  # noqa: E501
            return data

    def get_document_permission_set_with_http_info(self, did, **kwargs):  # noqa: E501
        """Get Document Permissions  # noqa: E501

        Get the permission set for a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_document_permission_set_with_http_info(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_document_permission_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `get_document_permission_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/{did}/permissionset', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_documents(self, **kwargs):  # noqa: E501
        """Get Documents  # noqa: E501

        Search for documents  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_documents(async=True)
        >>> result = thread.get()

        :param async bool
        :param str q: Search for documents that contain the given string in the name. Search is           not case-sensitive.
        :param float filter: Filter ID, which can be 0: my docs, 1: created, 2: shared, 3: trash,           4: public, 5: recent, 6: by owner, 7: by company, or 9: by team
        :param str owner: Document owner's ID if filter is 6 or 7. Team Id if filter is 9
        :param float owner_type: Type of owner, which can be 0: user, 1: company, 2: onshape. If           owner is a teamId, leave this unspecified.
        :param str sort_column: Column by which to sort search results. Valid options           are name, modifiedAt, createdAt, email, modifiedBy, and promotedAt
        :param str sort_order: Sort order, which can be desc: descending, or asc: ascending
        :param float offset: Where to begin search results
        :param float limit: Number of results to return per page (max is 20)
        :return: DocumentsGetDocumentsResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_documents_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_documents_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_documents_with_http_info(self, **kwargs):  # noqa: E501
        """Get Documents  # noqa: E501

        Search for documents  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_documents_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str q: Search for documents that contain the given string in the name. Search is           not case-sensitive.
        :param float filter: Filter ID, which can be 0: my docs, 1: created, 2: shared, 3: trash,           4: public, 5: recent, 6: by owner, 7: by company, or 9: by team
        :param str owner: Document owner's ID if filter is 6 or 7. Team Id if filter is 9
        :param float owner_type: Type of owner, which can be 0: user, 1: company, 2: onshape. If           owner is a teamId, leave this unspecified.
        :param str sort_column: Column by which to sort search results. Valid options           are name, modifiedAt, createdAt, email, modifiedBy, and promotedAt
        :param str sort_order: Sort order, which can be desc: descending, or asc: ascending
        :param float offset: Where to begin search results
        :param float limit: Number of results to return per page (max is 20)
        :return: DocumentsGetDocumentsResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['q', 'filter', 'owner', 'owner_type', 'sort_column', 'sort_order', 'offset', 'limit']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_documents" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('filter', params['filter']))  # noqa: E501
        if 'owner' in params:
            query_params.append(('owner', params['owner']))  # noqa: E501
        if 'owner_type' in params:
            query_params.append(('ownerType', params['owner_type']))  # noqa: E501
        if 'sort_column' in params:
            query_params.append(('sortColumn', params['sort_column']))  # noqa: E501
        if 'sort_order' in params:
            query_params.append(('sortOrder', params['sort_order']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsGetDocumentsResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_element_list(self, wvm_char, did, wvm, **kwargs):  # noqa: E501
        """Element List  # noqa: E501

        Get a list of elements in the workspace, version, or microversion of the document.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_element_list(wvm_char, did, wvm, async=True)
        >>> result = thread.get()

        :param async bool
        :param str wvm_char: One of w or v or m corresponding to whether a workspace or version or microversion was entered. (required)
        :param str did: Document ID (required)
        :param str wvm: Workspace (w), Version (v) or Microversion (m) ID (required)
        :param str element_type: Return only elements of this elementType
        :param str element_id: Return only element with this ID
        :param bool with_thumbnails: If true, include element thumbnail information
        :return: DocumentsGetElementListResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_element_list_with_http_info(wvm_char, did, wvm, **kwargs)  # noqa: E501
        else:
            (data) = self.get_element_list_with_http_info(wvm_char, did, wvm, **kwargs)  # noqa: E501
            return data

    def get_element_list_with_http_info(self, wvm_char, did, wvm, **kwargs):  # noqa: E501
        """Element List  # noqa: E501

        Get a list of elements in the workspace, version, or microversion of the document.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_element_list_with_http_info(wvm_char, did, wvm, async=True)
        >>> result = thread.get()

        :param async bool
        :param str wvm_char: One of w or v or m corresponding to whether a workspace or version or microversion was entered. (required)
        :param str did: Document ID (required)
        :param str wvm: Workspace (w), Version (v) or Microversion (m) ID (required)
        :param str element_type: Return only elements of this elementType
        :param str element_id: Return only element with this ID
        :param bool with_thumbnails: If true, include element thumbnail information
        :return: DocumentsGetElementListResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['wvm_char', 'did', 'wvm', 'element_type', 'element_id', 'with_thumbnails']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_element_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'wvm_char' is set
        if ('wvm_char' not in params or
                params['wvm_char'] is None):
            raise ValueError("Missing the required parameter `wvm_char` when calling `get_element_list`")  # noqa: E501
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `get_element_list`")  # noqa: E501
        # verify the required parameter 'wvm' is set
        if ('wvm' not in params or
                params['wvm'] is None):
            raise ValueError("Missing the required parameter `wvm` when calling `get_element_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'wvm_char' in params:
            path_params['wvm_char'] = params['wvm_char']  # noqa: E501
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501
        if 'wvm' in params:
            path_params['wvm'] = params['wvm']  # noqa: E501

        query_params = []
        if 'element_type' in params:
            query_params.append(('elementType', params['element_type']))  # noqa: E501
        if 'element_id' in params:
            query_params.append(('elementId', params['element_id']))  # noqa: E501
        if 'with_thumbnails' in params:
            query_params.append(('withThumbnails', params['with_thumbnails']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/d/{did}/{wvm_char}/{wvm}/elements', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsGetElementListResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_insertables(self, did, vid, **kwargs):  # noqa: E501
        """Insertable List for Document Version.  # noqa: E501

        Get a list of insertables in the version of the document.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_insertables(did, vid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param str vid: Version ID (required)
        :param str beta_capability_ids: Beta capablities of the document requesting insertables
        :param bool include_parts: Returns parts
        :param bool include_surfaces: Returns surfaces
        :param bool include_wires: Returns wires
        :param bool include_sketches: Returns sketches
        :param bool include_reference_features: Returns reference features
        :param bool include_assemblies: Returns assemblies
        :param bool include_feature_studios: Returns feature studios
        :param bool include_features: Returns features
        :param bool include_blobs: Returns blobs
        :param bool include_meshes: Returns meshes
        :param bool include_flattened_bodies: Returns flattened sheetmetal bodies
        :param bool include_applications: Return applications
        :param str allowed_blob_mime_types: Comma separated list of blob mime types to include
        :param str allowed_application_mime_types: Comma separated list of application format ids to           include
        :param float max_feature_script_version: If specified and is greater than zero, insertables           that are created using feature script version less than or equal to maxFeatureScriptVersion will be           returned
        :return: DocumentsGetInsertablesResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_insertables_with_http_info(did, vid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_insertables_with_http_info(did, vid, **kwargs)  # noqa: E501
            return data

    def get_insertables_with_http_info(self, did, vid, **kwargs):  # noqa: E501
        """Insertable List for Document Version.  # noqa: E501

        Get a list of insertables in the version of the document.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_insertables_with_http_info(did, vid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param str vid: Version ID (required)
        :param str beta_capability_ids: Beta capablities of the document requesting insertables
        :param bool include_parts: Returns parts
        :param bool include_surfaces: Returns surfaces
        :param bool include_wires: Returns wires
        :param bool include_sketches: Returns sketches
        :param bool include_reference_features: Returns reference features
        :param bool include_assemblies: Returns assemblies
        :param bool include_feature_studios: Returns feature studios
        :param bool include_features: Returns features
        :param bool include_blobs: Returns blobs
        :param bool include_meshes: Returns meshes
        :param bool include_flattened_bodies: Returns flattened sheetmetal bodies
        :param bool include_applications: Return applications
        :param str allowed_blob_mime_types: Comma separated list of blob mime types to include
        :param str allowed_application_mime_types: Comma separated list of application format ids to           include
        :param float max_feature_script_version: If specified and is greater than zero, insertables           that are created using feature script version less than or equal to maxFeatureScriptVersion will be           returned
        :return: DocumentsGetInsertablesResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did', 'vid', 'beta_capability_ids', 'include_parts', 'include_surfaces', 'include_wires', 'include_sketches', 'include_reference_features', 'include_assemblies', 'include_feature_studios', 'include_features', 'include_blobs', 'include_meshes', 'include_flattened_bodies', 'include_applications', 'allowed_blob_mime_types', 'allowed_application_mime_types', 'max_feature_script_version']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_insertables" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `get_insertables`")  # noqa: E501
        # verify the required parameter 'vid' is set
        if ('vid' not in params or
                params['vid'] is None):
            raise ValueError("Missing the required parameter `vid` when calling `get_insertables`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501
        if 'vid' in params:
            path_params['vid'] = params['vid']  # noqa: E501

        query_params = []
        if 'beta_capability_ids' in params:
            query_params.append(('betaCapabilityIds', params['beta_capability_ids']))  # noqa: E501
        if 'include_parts' in params:
            query_params.append(('includeParts', params['include_parts']))  # noqa: E501
        if 'include_surfaces' in params:
            query_params.append(('includeSurfaces', params['include_surfaces']))  # noqa: E501
        if 'include_wires' in params:
            query_params.append(('includeWires', params['include_wires']))  # noqa: E501
        if 'include_sketches' in params:
            query_params.append(('includeSketches', params['include_sketches']))  # noqa: E501
        if 'include_reference_features' in params:
            query_params.append(('includeReferenceFeatures', params['include_reference_features']))  # noqa: E501
        if 'include_assemblies' in params:
            query_params.append(('includeAssemblies', params['include_assemblies']))  # noqa: E501
        if 'include_feature_studios' in params:
            query_params.append(('includeFeatureStudios', params['include_feature_studios']))  # noqa: E501
        if 'include_features' in params:
            query_params.append(('includeFeatures', params['include_features']))  # noqa: E501
        if 'include_blobs' in params:
            query_params.append(('includeBlobs', params['include_blobs']))  # noqa: E501
        if 'include_meshes' in params:
            query_params.append(('includeMeshes', params['include_meshes']))  # noqa: E501
        if 'include_flattened_bodies' in params:
            query_params.append(('includeFlattenedBodies', params['include_flattened_bodies']))  # noqa: E501
        if 'include_applications' in params:
            query_params.append(('includeApplications', params['include_applications']))  # noqa: E501
        if 'allowed_blob_mime_types' in params:
            query_params.append(('allowedBlobMimeTypes', params['allowed_blob_mime_types']))  # noqa: E501
        if 'allowed_application_mime_types' in params:
            query_params.append(('allowedApplicationMimeTypes', params['allowed_application_mime_types']))  # noqa: E501
        if 'max_feature_script_version' in params:
            query_params.append(('maxFeatureScriptVersion', params['max_feature_script_version']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/d/{did}/v/{vid}/insertables', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsGetInsertablesResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_version(self, did, vid, **kwargs):  # noqa: E501
        """Get Version  # noqa: E501

        Get information about a version  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_version(did, vid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param str vid: Version ID (required)
        :param str link_document_id: Id of document that links to the document being accessed.     This may provide additional access rights to the document. Allowed only with version (v) path parameter.
        :return: DocumentsGetVersionResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_version_with_http_info(did, vid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_version_with_http_info(did, vid, **kwargs)  # noqa: E501
            return data

    def get_version_with_http_info(self, did, vid, **kwargs):  # noqa: E501
        """Get Version  # noqa: E501

        Get information about a version  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_version_with_http_info(did, vid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param str vid: Version ID (required)
        :param str link_document_id: Id of document that links to the document being accessed.     This may provide additional access rights to the document. Allowed only with version (v) path parameter.
        :return: DocumentsGetVersionResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did', 'vid', 'link_document_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `get_version`")  # noqa: E501
        # verify the required parameter 'vid' is set
        if ('vid' not in params or
                params['vid'] is None):
            raise ValueError("Missing the required parameter `vid` when calling `get_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501
        if 'vid' in params:
            path_params['vid'] = params['vid']  # noqa: E501

        query_params = []
        if 'link_document_id' in params:
            query_params.append(('linkDocumentId', params['link_document_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/d/{did}/versions/{vid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsGetVersionResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_versions(self, did, **kwargs):  # noqa: E501
        """Get Versions  # noqa: E501

        Get the versions in a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_versions(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param float offset: Where to begin search results
        :param float limit: Number of results to return per page. When specified, it cannot exceed           20. Default is unlimited
        :return: DocumentsGetVersionsResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_versions_with_http_info(did, **kwargs)  # noqa: E501
        else:
            (data) = self.get_versions_with_http_info(did, **kwargs)  # noqa: E501
            return data

    def get_versions_with_http_info(self, did, **kwargs):  # noqa: E501
        """Get Versions  # noqa: E501

        Get the versions in a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_versions_with_http_info(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param float offset: Where to begin search results
        :param float limit: Number of results to return per page. When specified, it cannot exceed           20. Default is unlimited
        :return: DocumentsGetVersionsResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did', 'offset', 'limit']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_versions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `get_versions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/d/{did}/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsGetVersionsResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_workspaces(self, did, **kwargs):  # noqa: E501
        """Get Workspaces  # noqa: E501

        List workspaces in document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_workspaces(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param str noreadonly: Do not return read-only workspaces
        :return: DocumentsGetWorkspacesResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_workspaces_with_http_info(did, **kwargs)  # noqa: E501
        else:
            (data) = self.get_workspaces_with_http_info(did, **kwargs)  # noqa: E501
            return data

    def get_workspaces_with_http_info(self, did, **kwargs):  # noqa: E501
        """Get Workspaces  # noqa: E501

        List workspaces in document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_workspaces_with_http_info(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param str noreadonly: Do not return read-only workspaces
        :return: DocumentsGetWorkspacesResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did', 'noreadonly']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workspaces" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `get_workspaces`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501

        query_params = []
        if 'noreadonly' in params:
            query_params.append(('noreadonly', params['noreadonly']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/d/{did}/workspaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsGetWorkspacesResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def move_elements_to_document(self, did, wid, **kwargs):  # noqa: E501
        """Move Elements  # noqa: E501

        Move elements from a source document to a destination document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.move_elements_to_document(did, wid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param str wid: Workspace ID (required)
        :param DocumentsMoveElementsToDocumentBody body: The JSON request body.
        :return: DocumentsMoveElementsToDocumentResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.move_elements_to_document_with_http_info(did, wid, **kwargs)  # noqa: E501
        else:
            (data) = self.move_elements_to_document_with_http_info(did, wid, **kwargs)  # noqa: E501
            return data

    def move_elements_to_document_with_http_info(self, did, wid, **kwargs):  # noqa: E501
        """Move Elements  # noqa: E501

        Move elements from a source document to a destination document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.move_elements_to_document_with_http_info(did, wid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param str wid: Workspace ID (required)
        :param DocumentsMoveElementsToDocumentBody body: The JSON request body.
        :return: DocumentsMoveElementsToDocumentResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did', 'wid', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_elements_to_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `move_elements_to_document`")  # noqa: E501
        # verify the required parameter 'wid' is set
        if ('wid' not in params or
                params['wid'] is None):
            raise ValueError("Missing the required parameter `wid` when calling `move_elements_to_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501
        if 'wid' in params:
            path_params['wid'] = params['wid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/d/{did}/w/{wid}/moveelement', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsMoveElementsToDocumentResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def share_document(self, did, **kwargs):  # noqa: E501
        """Share Document  # noqa: E501

        Share document with one or more entities, which may be users, companies, teams or applications.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.share_document(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param DocumentsShareDocumentBody body: The JSON request body.
        :return: DocumentsShareDocumentResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.share_document_with_http_info(did, **kwargs)  # noqa: E501
        else:
            (data) = self.share_document_with_http_info(did, **kwargs)  # noqa: E501
            return data

    def share_document_with_http_info(self, did, **kwargs):  # noqa: E501
        """Share Document  # noqa: E501

        Share document with one or more entities, which may be users, companies, teams or applications.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.share_document_with_http_info(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param DocumentsShareDocumentBody body: The JSON request body.
        :return: DocumentsShareDocumentResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method share_document" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `share_document`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/{did}/share', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsShareDocumentResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def un_share(self, eid, did, **kwargs):  # noqa: E501
        """Unshare Document  # noqa: E501

        Remove share permissions from document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.un_share(eid, did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str eid: Entry ID of the share entry to be deleted (required)
        :param str did: Document ID (required)
        :param float entry_type: The type of entity referenced by eid. Valid values are      0=User, 1=Company, 2=Team, 4=Application.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.un_share_with_http_info(eid, did, **kwargs)  # noqa: E501
        else:
            (data) = self.un_share_with_http_info(eid, did, **kwargs)  # noqa: E501
            return data

    def un_share_with_http_info(self, eid, did, **kwargs):  # noqa: E501
        """Unshare Document  # noqa: E501

        Remove share permissions from document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.un_share_with_http_info(eid, did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str eid: Entry ID of the share entry to be deleted (required)
        :param str did: Document ID (required)
        :param float entry_type: The type of entity referenced by eid. Valid values are      0=User, 1=Company, 2=Team, 4=Application.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['eid', 'did', 'entry_type']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method un_share" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'eid' is set
        if ('eid' not in params or
                params['eid'] is None):
            raise ValueError("Missing the required parameter `eid` when calling `un_share`")  # noqa: E501
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `un_share`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'eid' in params:
            path_params['eid'] = params['eid']  # noqa: E501
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501

        query_params = []
        if 'entry_type' in params:
            query_params.append(('entryType', params['entry_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/{did}/share/{eid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_document_attributes(self, did, **kwargs):  # noqa: E501
        """Update Document Attributes.  # noqa: E501

        Update document attributes name, description  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_document_attributes(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param DocumentsUpdateDocumentAttributesBody body: The JSON request body.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_document_attributes_with_http_info(did, **kwargs)  # noqa: E501
        else:
            (data) = self.update_document_attributes_with_http_info(did, **kwargs)  # noqa: E501
            return data

    def update_document_attributes_with_http_info(self, did, **kwargs):  # noqa: E501
        """Update Document Attributes.  # noqa: E501

        Update document attributes name, description  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_document_attributes_with_http_info(did, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param DocumentsUpdateDocumentAttributesBody body: The JSON request body.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_document_attributes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `update_document_attributes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/{did}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_external_references_to_latest_documents(self, did, wid, eid, **kwargs):  # noqa: E501
        """Update External References to Latest  # noqa: E501

        Update the external references to the latest documents if the referenced external elements have been parted out  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_external_references_to_latest_documents(did, wid, eid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param str wid: Workspace ID (required)
        :param str eid: Element ID (required)
        :param DocumentsUpdateExternalReferencesToLatestDocumentsBody body: The JSON request body.
        :return: DocumentsUpdateExternalReferencesToLatestDocumentsResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_external_references_to_latest_documents_with_http_info(did, wid, eid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_external_references_to_latest_documents_with_http_info(did, wid, eid, **kwargs)  # noqa: E501
            return data

    def update_external_references_to_latest_documents_with_http_info(self, did, wid, eid, **kwargs):  # noqa: E501
        """Update External References to Latest  # noqa: E501

        Update the external references to the latest documents if the referenced external elements have been parted out  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_external_references_to_latest_documents_with_http_info(did, wid, eid, async=True)
        >>> result = thread.get()

        :param async bool
        :param str did: Document ID (required)
        :param str wid: Workspace ID (required)
        :param str eid: Element ID (required)
        :param DocumentsUpdateExternalReferencesToLatestDocumentsBody body: The JSON request body.
        :return: DocumentsUpdateExternalReferencesToLatestDocumentsResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['did', 'wid', 'eid', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_external_references_to_latest_documents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'did' is set
        if ('did' not in params or
                params['did'] is None):
            raise ValueError("Missing the required parameter `did` when calling `update_external_references_to_latest_documents`")  # noqa: E501
        # verify the required parameter 'wid' is set
        if ('wid' not in params or
                params['wid'] is None):
            raise ValueError("Missing the required parameter `wid` when calling `update_external_references_to_latest_documents`")  # noqa: E501
        # verify the required parameter 'eid' is set
        if ('eid' not in params or
                params['eid'] is None):
            raise ValueError("Missing the required parameter `eid` when calling `update_external_references_to_latest_documents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'did' in params:
            path_params['did'] = params['did']  # noqa: E501
        if 'wid' in params:
            path_params['wid'] = params['wid']  # noqa: E501
        if 'eid' in params:
            path_params['eid'] = params['eid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['OAuth2', 'apiAccessKey', 'apiSecretKey']  # noqa: E501

        return self.api_client.call_api(
            '/documents/d/{did}/w/{wid}/e/{eid}/latestdocumentreferences', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DocumentsUpdateExternalReferencesToLatestDocumentsResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
